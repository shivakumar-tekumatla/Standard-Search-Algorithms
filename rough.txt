            # not_collision = self.check_collision(point, nearest_node)# extend the node and check collision to decide whether to add or drop,
            # print(not_collision,point.row,point.col,nearest_node.row,nearest_node.col)
            # if not_collision:
                            # print(next_point.row,next_point.col,next_point.parent.row,next_point.parent.col)
                # print(itr)
                # next_point.cost = self.dis(next_point,self.goal)



                # y1,y2 = -y1,-y2  # going down row incerase but y coordinate decreases 
        # x1,y1,x2,y2 = min(x1,x2),min(y1,y2),max(x1,x2),max(y1,y2)

        # dy = y2-y1
        # dx = x2-x1 
        # x,y = x1,y1 # starting from the first point 
        # sx = -1 if x1>x2 else 1
        # sy = -1 if y1>y2 else 1

        # if dx>dy:
        #     error = dx/2.0
        #     while x!=x2:
        #         if self.map_array[y][x] ==0:
        #             return False 
        #         error-=dy
        #         if error<0:
        #             y+=sy
        #             error+=dx
        #         x+=sx
        # else:
        #     error = dy/2.0
        #     while y!=y2:
        #         if self.map_array[y][x] ==0:
        #             return False
        #         error-=dx
        #         if error <0:
        #             x+=sx
        #             error+=dy
        #         y+=sy

        # if self.map_array[y2][x2] ==0:
        #     return False
        # else:
        #     return True 



                
        # query_pairs = self.kdtree.query_pairs(self.radius)
        # for pair in query_pairs:
        #     id1,id2 = pair
        #     if not self.check_collision(self.samples[id1],self.samples[id2]):
        #         pairs.append((id1,id2,self.dis(self.samples[id1],self.samples[id2])))
        # sample_id=0
        # for sample in self.samples:
        #     distances,indices = self.kdtree.query(sample,self.k_neighbors)
        #     for i in range(0,len(indices)):
        #         if not self.check_collision(sample,self.samples[indices[i]]):
        #             pairs.append((sample_id,indices[i],distances[i]))
        #     sample_id+=1
        